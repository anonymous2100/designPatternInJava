# 设计模式的Java代码实现   
23种设计模式的Java代码实现，本项目的主要目的是为了学习理解设计模式的思想。  
 
【创建型模式】     
1、单例模式   
com.ctgu.singleton  
应用场景：  
（1）在应用场景中，某类只要求生成一个对象的时候；  
（2）当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。  
（3）当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。  

2、原型模式    
com.ctgu.prototype       
应用场景：   
（1）对象之间相同或相似，即只是个别的几个属性不同的时候。  
（2）对象的创建过程比较麻烦，但复制比较简单的时候。  

3、简单工厂方法模式     
又称静态方法模式（因为工厂类定义了一个静态方法）简单工厂模式可以理解为负责生产对象的一个类，称为“工厂类”。   
com.ctgu.simple_factory_method  

3、工厂方法模式    
com.ctgu.factory_mathod    
应用场景：   
（1）客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。  
（2）创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。  
（3）客户不关心创建产品的细节，只关心产品的品牌。  

4、抽象工厂模式    
com.ctgu.abstract_factory     
应用场景：   
（1）当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。  
（2）系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。  
（3）系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。  

5、建造者模式     
com.ctgu.builder      
建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。  
应用场景：   
（1）创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。  
（2）创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。  


【结构型模式】    
6、代理模式   
com.ctgu.proxy    

7、适配器模式  
com.ctgu.adapter  

8、桥接模式  

9、装饰模式  
com.ctgu.decorator  

10、外观模式  
com.ctgu.facade  

11、享元模式  
com.ctgu.flyweight  

12、组合模式  
com.ctgu.combination  


【行为型模式】   
13、模板方法模式   
com.ctgu.template_method  

14、策略模式   
com.ctgu.strategy  

15、命令模式   
com.ctgu.command  

16、责任链模式   
com.ctgu.responsibility_chain  

17、状态模式    
com.ctgu.state  

18、观察者模式   
com.ctgu.observer_mode  

19、中介者模式   
com.ctgu.mediator  

20、迭代器模式   
com.ctgu.iterative_subpattern  

21、访问者模式   
com.ctgu.visitor

22、备忘录模式    

 
23、解释器模式    


# 补充资料          
一、设计模式概述  
设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。  
它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。  
也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。  
其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。  

二、设计模式的分类  
1、根据目的来分  
根据模式是用来完成什么工作来划分，这种方式可以分为3种，创建型模式、结构型模式、行为型模式。  
（1）创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。    
（2）结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。    
（3）行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、
状态模式、访问者模式、中介者模式、解释器模式。    

2、根据作用范围来分  
根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。  
（1）类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。  
属于该模式的有：工厂方法、	(类）适配器、模板方法、解释器 ；   
（2）对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。  
属于该模式的有：单例、代理、策略、原型、（对象）适配器、命令、抽象工厂、桥接、责任链、建造者、外观、状态、装饰、
	观察者、享元、	中介者、组合、	迭代器、访问者、备忘录    
	
用一个图片来整体描述一下：  
![avatar](img/design_pattern.jpg)

三、设计模式的六大原则  
总原则：开闭原则（Open Close Principle）    
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。
所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，
后面的具体设计中我们会提到这点。  

1、单一职责原则    
不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。  

2、里氏替换原则（Liskov Substitution Principle）  
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。
 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，
 软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。  
 里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。
 而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  

里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，
子类不应该随便破坏它。  

3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，
而与具体类的上层接口交互。  

4、接口隔离原则（Interface Segregation Principle）  
这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，
比使用单个接口（多个接口方法集合到一个的接口）要好。  

5、迪米特法则（最少知道原则）（Demeter Principle）  
就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，
通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。  

最少知道原则的另一个表达方式是：只与直接的朋友通信。  
类之间只要有耦合关系，就叫朋友关系。  
耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。    
局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。    

6、合成复用原则（Composite Reuse Principle）  
原则是尽量首先使用合成/聚合的方式，而不是使用继承。  



 











 
















